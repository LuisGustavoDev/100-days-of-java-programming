# 100 Days of Java Programming

This repository contains my progress through the **100 Days of Java Programming** challenge. Over the next 100 days, I will be working on improving my skills in Java, covering a wide range of topics such as Object-Oriented Programming (OOP), advanced Java, frameworks, and real-world project development.

The goal is to commit to daily programming practice and build a strong foundation in Java.

## Day 1-3: Object-Oriented Programming and Code Structuring in Java

Over the first three days, I focused on learning core concepts of **Object-Oriented Programming (OOP)** in Java, such as **inheritance**, **method overriding**, **polymorphism**, and **code structuring**. On Day 1, I practiced **inheritance**, which allowed me to create a base class and then extend it with specialized subclasses. I also learned about **method overriding**, which enabled me to change the behavior of methods inherited from the superclass in the subclass. **Polymorphism** was introduced to me as the ability of different objects to respond to the same method call in their own unique ways, based on their actual class type. On Day 2, I continued applying inheritance and method overriding, while focusing on organizing and structuring my code more efficiently. I practiced using the **super()** keyword to initialize attributes from the parent class in subclasses, and worked on making my code more modular. On Day 3, I expanded on these concepts by building more exercises that involved overriding methods to provide different behaviors and organizing the code into clean, manageable pieces. These exercises helped solidify my understanding of how OOP principles work together to create flexible and maintainable code.

## Day 4: Collections in Java and Data Structures

On **Day 4**, I focused on using **Collections** in Java, specifically `ArrayList`, to manage a dynamic group of objects. I worked with the **ContactRepository** class to efficiently store and manipulate contacts, practicing adding new contacts, searching for them by keyword, and displaying the list using the `toString()` method. I applied abstraction by encapsulating **contact** details in the Contact class and used polymorphism to manage and filter the data, helping me deepen my understanding of how to organize and handle collections of objects in Java.

## Day 5: Extending the Call Management System

On **Day 5**, I extended the project from Day 4 by adding a **Call Management System**. Building on the **Collections** concepts learned previously, I created the **Call** and **CallRepository** classes to track and store phone call details. I applied **encapsulation** to manage call information and used **polymorphism** by overloading the `call` method to support both `Contact` objects and phone numbers. Additionally, I incorporated Java's `LocalDateTime` and `DateTimeFormatter` to log call times. The **CallRepository** was integrated into the `CellPhone` class to track call history, demonstrating **composition**. This extension deepened my understanding of handling complex object interactions in Java.

## Day 6: Static Methods and Fields in Java

On **Day 6**, I learned to apply **static methods** and **static fields** in Java. I created a **Math** class with static methods (`sum()`, `square()`, `circleArea()`) for reusable functionality without creating an instance. I also used a static field, `piValue`, shared across all instances of the class. In the **Car** class, I used constructors to initialize attributes like `name` and `year`, and explored the difference between **static** and **instance variables**. This day deepened my understanding of static elements in Java.
